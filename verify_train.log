3227920it [01:30, 34086.22it/s]Invalid line: The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on ( 1 ) /tmp/rs-filter-graph.png or ( 2 ) /tmp/rs-filter-graph .      "fixes insecure use of temporary file ( cve-2014-4978 ) . diff - - git a / librawstudio / rs - filter . c b / librawstudio / rs - filter . c \ n @ @ - 772 , 17 + 772 , 32 @ @ void \ n + gchar * dot_filename ; \ n + gchar * png_filename ; \ n + gchar * command_line ; \ n - g_file_set_contents ( ""/tmp/rs-filter-graph"" , str - > str , str - > len , null ) ; \ n - if ( 0 ! = system ( ""dot -tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph"" ) ) \ n + /* here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */ \ n + dot_filename = g_strdup_printf ( ""/tmp/rs-filter-graph.%u"" , g_random_int ( ) ) ; \ n + png_filename = g_strdup_printf ( ""%s.%u.png"" , dot_filename , g_random_int ( ) ) ; \ n + \ n + g_file_set_contents ( dot_filename , str - > str , str - > len , null ) ; \ n + \ n + command_line = g_strdup_printf ( ""dot -tpng >%s <%s"" , png_filename , dot_filename ) ; \ n + if ( 0 ! = system ( command_line ) ) \ n - if ( 0 ! = system ( ""gnome-open /tmp/rs-filter-graph.png"" ) ) \ n + g_free ( command_line ) ; \ n + \ n + command_line = g_strdup_printf ( ""gnome-open %s"" , png_filename ) ; \ n + if ( 0 ! = system ( command_line ) ) \ n + g_free ( command_line ) ; \ n + g_free ( dot_filename ) ; \ n + g_free ( png_filename ) ;"       

4294898it [03:43, 43557.93it/s]Invalid line: The InvertibleRWFunction : :CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm , which allows remote attackers to obtain private keys via a timing attack .    fix for cve-2015-2141 . thanks to evgeny sidorov for reporting . squaring to satisfy jacobi requirements suggested by jpm . diff - - git a / rw . cpp b / rw . cpp \ n @ @ - 126 , 10 + 126 , 16 @ @ integer invertiblerwfunction : : calculateinverse ( randomnumbergenerator & rng , const \ n - do { // do this in a loop for people using small numbers for testing\n+\n+ // do this in a loop for people using small numbers for testing\n+ do {\n+  // fix for cve-2015-2141. thanks to evgeny sidorov for reporting.\n+  // squaring to satisfy jacobi requirements suggested by jpm.\n+  r = modn.square(r);\n+        

4596068it [03:51, 42311.75it/s]Invalid line: Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service ( crash ) via a crafted image , which triggers a buffer overflow , related to the len variable .  avoid overflow in ljpeg_start ( ) . diff - - git a / plugins / load - dcraw / dcraw . cc b / plugins / load - dcraw / dcraw . cc \ n @ @ - 890 , 7 + 890 , 8 @ @ struct jhead { \ n - int c , tag , len ; \ n + int c , tag ; \ n + ushort len ;         

12904906it [07:13, 47066.07it/s]Invalid line: Crypto++ ( aka cryptopp ) through 5.6.5 contains an out-of-bounds read vulnerability in zinflate.cpp in the Inflator filter .        "add inflator : :baddistanceerr exception ( issue 414 ) the improved validation and excpetion clears the address sanitizer and undefined behavior sanitizer findings diff - - git a / validat1 . cpp b / validat1 . cpp \ n @ @ - 623 , 7 + 623 , 7 @ @ bool testrandompool ( ) \ n - std : : cout < < ""  generateword32 and crop\n"" ; \ n + std : : cout < < ""  generateword32 and crop\n"" ; \ n @ @ - 711 , 7 + 711 , 7 @ @ bool testrandompool ( ) \ n - std : : cout < < ""  generateword32 and crop\n"" ; \ n + std : : cout < < ""  generateword32 and crop\n"" ; \ n @ @ - 808 , 7 + 808 , 7 @ @ bool testautoseededx917 ( ) \ n - std : : cout < < ""  generateword32 and crop\n"" ; \ n + std : : cout < < ""  generateword32 and crop\n"" ; \ ndiff - - git a / zinflate . cpp b / zinflate . cpp \ n @ @ - 552 , 12 + 552 , 18 @ @ bool inflator : : decodebody ( ) \ n - bits = ( m_distance > = countof ( distanceextrabits ) ) ? distanceextrabits [ 29 ] : distanceextrabits [ m_distance ] ; \ n + if ( m_distance > = countof ( distanceextrabits ) ) \ n + throw baddistanceerr ( ) ; \ n + bits = distanceextrabits [ m_distance ] ; \ n + // todo: this surfaced during fuzzing. what do we do???\n+     cryptopp_assert(m_distance < countof(distancestarts));\n+     if (m_distance >= countof(distancestarts))\n+      throw baddistanceerr();\ndiff --git a/zinflate.h b/zinflate.h\n@@ -98,8 +98,12 @@ public:\n+ //! \brief exception thrown when a truncated stream is encountered\n+ //! \brief exception thrown when a bad block is encountered\n+ //! \brief exception thrown when an invalid distance is encountered\n+ class baddistanceerr : public err {public: baddistanceerr() : err(invalid_data_format, ""inflator: error in bit distance"") {}};"     

18921437it [09:45, 35119.79it/s]Invalid line: Exiv2 is a command-line utility and C++ library for reading , writing , deleting , and modifying the metadata of image files . An out-of-bounds read was found in Exiv2 versions v0.27.3 and earlier . The out-of-bounds read is triggered when Exiv2 is used to write metadata into a crafted image file . An attacker could potentially exploit the vulnerability to cause a denial of service by crashing Exiv2 , if they can trick the victim into running Exiv2 on a crafted image file . Note that this bug is only triggered when writing the metadata , which is a less frequently used Exiv2 operation than reading the metadata . For example , to trigger the bug in the Exiv2 command-line application , you need to add an extra command-line argument such as ` insert ` . The bug is fixed in version v0.27.4 .   improve bound checking in webpimage : :dowritemetadata ( ) diff - - git a / src / webpimage . cpp b / src / webpimage . cpp \ n @ @ - 145 , 7 + 145 , 7 @ @ namespace exiv2 { \ n - io_ - > read ( data , webp_tag_size * 3 ) ; \ n + readorthrow ( * io_ , data , webp_tag_size * 3 , exiv2 : : kercorruptedmetadata ) ; \ n @ @ - 185 , 13 + 185 , 20 @ @ namespace exiv2 { \ n - io_ - > read ( chunkid . pdata_ , webp_tag_size ) ; \ n - io_ - > read ( size_buff , webp_tag_size ) ; \ n - long size = exiv2 : : getulong ( size_buff , littleendian ) ; \ n + readorthrow ( * io_ , chunkid . pdata_ , webp_tag_size , exiv2 : : kercorruptedmetadata ) ; \ n + readorthrow ( * io_ , size_buff , webp_tag_size , exiv2 : : kercorruptedmetadata ) ; \ n + const uint32_t size_u32 = exiv2 : : getulong ( size_buff , littleendian ) ; \ n + \ n + // check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    exiv2::kercorruptedmetadata);\n+            const long size = static_cast<long>(size_u32);\n-            io_->read(payload.pdata_, payload.size_);\n-            byte c;\n-            if ( payload.size_ % 2 ) io_->read(&c,1);\n+            readorthrow(*io_, payload.pdata_, payload.size_, exiv2::kercorruptedmetadata);\n+            if ( payload.size_ % 2 ) {\n+              byte c;\n+              readorthrow(*io_, &c, 1, exiv2::kercorruptedmetadata);\n+            }\n@@ -199,6 +206,7 @@ namespace exiv2 {\n+                enforce(size >= 10, exiv2::kercorruptedmetadata);\n@@ -227,6 +235,7 @@ namespace exiv2 {\n+                enforce(size >= 10, exiv2::kercorruptedmetadata);\n@@ -244,11 +253,13 @@ namespace exiv2 {\n+                enforce(size >= 5, exiv2::kercorruptedmetadata);\n+                enforce(size >= 5, exiv2::kercorruptedmetadata);\n@@ -276,11 +287,13 @@ namespace exiv2 {\n+                enforce(size >= 6, exiv2::kercorruptedmetadata);\n+                enforce(size >= 12, exiv2::kercorruptedmetadata);\n@@ -309,16 +322,22 @@ namespace exiv2 {\n-            io_->read(chunkid.pdata_, 4);\n-            io_->read(size_buff, 4);\n+            readorthrow(*io_, chunkid.pdata_, 4, exiv2::kercorruptedmetadata);\n+            readorthrow(*io_, size_buff, 4, exiv2::kercorruptedmetadata);\n+\n+            const uint32_t size_u32 = exiv2::getulong(size_buff, littleendian);\n-            long size = exiv2::getulong(size_buff, littleendian);\n+            // check that `size_u32` is safe to cast to `long`.\n+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<unsigned int>::max()),\n+                    exiv2::kercorruptedmetadata);\n+            const long size = static_cast<long>(size_u32);\n-            io_->read(payload.pdata_, size);\n+            readorthrow(*io_, payload.pdata_, size, exiv2::kercorruptedmetadata);\n+                enforce(size >= 1, exiv2::kercorruptedmetadata);      

22229009it [11:09, 33181.00it/s]